import shutil
from fpdf import FPDF
from datetime import datetime
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from matplotlib.patches import Patch
import tempfile
import os
import matplotlib.gridspec as gridspec


class PDFReportGenerator:
    def __init__(self, report_data, health_metrics, health_ranges, eeg_data_path):
        """
        Initialize PDF Report Generator

        Parameters:
        report_data: Dictionary containing sleep assessment data
        health_metrics: Dictionary containing health metrics
        health_ranges: Reference ranges for health metrics
        eeg_data_path: Path to EEG data file
        """
        self.report_data = report_data
        self.health_metrics = health_metrics
        self.health_ranges = health_ranges
        self.eeg_data_path = eeg_data_path
        self.temp_images = []  # Store temporary image file paths

        # 睡眠阶段映射（英文）
        self.stage_map = {
            0: "Wake",
            1: "N1",
            2: "N2",
            3: "N3",
            4: "REM"
        }

        # 更新为低饱和度颜色映射 - 柔和色调
        self.stage_colors = {
            0: (0.4, 0.6, 0.8),  # 浅蓝色 - Wake
            1: (0.6, 0.8, 0.9),  # 淡青色 - N1
            2: (0.6, 0.8, 0.6),  # 淡绿色 - N2
            3: (0.8, 0.5, 0.5),  # 柔红色 - N3
            4: (0.8, 0.7, 1.0)  # 淡紫色 - REM
        }

    def generate_report(self, file_path):
        """
        Generate PDF report and save to specified path
        """
        try:
            # Create PDF object - 不使用encoding参数
            pdf = FPDF()
            pdf.add_page()

            # 添加代理方法处理Unicode字符
            def add_unicode_text(pdf, text, size=10):
                """添加Unicode文本"""
                from fpdf import FPDF
                pdf.set_font("Arial", size=size)
                # 过滤掉部分特殊字符
                safe_text = text.encode('latin-1', 'replace').decode('latin-1')
                return safe_text

            # Add title
            self.add_report_header(pdf)

            # 首先添加睡眠阶段图（如果有数据）
            plot_added = False
            plot_height = 0
            if self.eeg_data_path and os.path.exists(self.eeg_data_path):
                try:
                    plot_path = self.generate_sleep_stage_plot_image()
                    self.temp_images.append(plot_path)

                    # 添加图片（放置在顶部）
                    current_y = pdf.get_y()
                    pdf.image(plot_path, x=10, w=190)
                    plot_added = True
                    plot_height = pdf.get_y() - current_y
                    pdf.set_y(pdf.get_y() + 5)  # 添加图片后增加一些空间
                except Exception as e:
                    print(f"Error adding sleep stage plot: {e}")

            # 如果没有添加图片，需要设置合适的起始位置
            if not plot_added:
                pdf.set_y(30)  # 标题下方位置

            # 将页面分为左右两栏
            left_x, right_x = 10, 105
            column_width = 95

            # 记录表格开始位置的y坐标
            table_start_y = pdf.get_y()

            # 添加左侧表格（睡眠指标）
            pdf.set_xy(left_x, table_start_y)
            pdf.set_font("Arial", "B", 10)
            pdf.cell(column_width, 8, "Sleep Assessment Metrics", ln=True, align='C')
            pdf.ln(3)
            self.add_sleep_metrics_table(pdf, left_x, column_width)

            # 获取左侧表格后的y位置
            left_table_end_y = pdf.get_y()

            # 添加右侧表格（健康指标）
            pdf.set_xy(right_x, table_start_y)
            pdf.set_font("Arial", "B", 10)
            pdf.cell(column_width, 8, "Health Monitoring Metrics", ln=True, align='C')
            pdf.ln(3)
            self.add_health_metrics_table(pdf, right_x, column_width)

            # 获取右侧表格后的y位置
            right_table_end_y = pdf.get_y()

            # 计算两个表格的最大结束位置
            max_table_end_y = max(left_table_end_y, right_table_end_y)
            pdf.set_y(max_table_end_y + 8)  # 添加8毫米的间距

            # 添加睡眠评估建议部分 - 修改方法以使用安全的项目符号
            self.add_english_recommendations(pdf, add_unicode_text)

            # 添加报告页脚
            pdf.set_y(pdf.get_y() + 8)  # 在建议和页脚之间增加空间
            pdf.set_font("Arial", "I", 10)
            pdf.cell(0, 8, "Report generated by Sleep Monitoring System", ln=True, align='C')

            # Save PDF file - 使用更安全的文件名处理
            try:
                pdf.output(file_path)
            except UnicodeEncodeError:
                # 如果文件名有问题，使用临时文件
                temp_path = tempfile.mktemp(".pdf")
                pdf.output(temp_path)
                shutil.copy(temp_path, file_path)
                os.remove(temp_path)

            # Clean up temporary files
            for img_path in self.temp_images:
                if os.path.exists(img_path):
                    os.remove(img_path)

            return True, f"Report successfully exported to: {file_path}"
        except Exception as e:
            # Ensure cleanup of temporary files
            for img_path in self.temp_images:
                if os.path.exists(img_path):
                    os.remove(img_path)
            return False, f"Report generation failed: {str(e)}"

    def add_english_recommendations(self, pdf, safe_text_func=None):
        """添加英文睡眠建议"""
        # 添加标题
        pdf.set_font("Arial", "B", 12)
        pdf.cell(0, 10, "Sleep Assessment Recommendations", ln=True, align='L')
        pdf.ln(2)  # 小间距

        # 生成英文建议
        english_suggestions = self.generate_english_suggestions()

        # 添加安全的文本
        if safe_text_func:
            safe_text = safe_text_func(pdf, english_suggestions)
        else:
            safe_text = english_suggestions.encode('ascii', 'ignore').decode('ascii')

        # 添加多行文本（使用安全格式）
        lines = safe_text.split('\n')
        for line in lines:
            if line:
                # 使用简单的格式代替项目符号
                pdf.set_x(15)  # 缩进位置
                pdf.multi_cell(180, 5, f"  - {line}", 0)  # 使用 - 代替•
                pdf.ln(1)  # 行间距

    def generate_english_suggestions(self):
        """Generate English recommendations based on sleep and health metrics"""
        suggestions = []

        # 直接获取睡眠评分
        sleep_score = self.report_data.get("sleep_score", 0)

        # 总体建议
        suggestions.append(
            "To improve sleep quality, consider reducing light and noise exposure before bedtime, for example by using blackout curtains or earplugs.")

        # 睡眠时长建议
        sleep_duration = self.report_data.get("sleep_duration", 0)
        if sleep_duration < 7:
            suggestions.append(
                f"Your sleep duration ({sleep_duration:.1f} hours) is below the recommended range. Aim for 7-9 hours of sleep per night.")
        elif sleep_duration > 9:
            suggestions.append(
                f"Your sleep duration ({sleep_duration:.1f} hours) exceeds the optimal range. Consider maintaining between 7-9 hours.")

        # 睡眠阶段建议
        deep_sleep = self.report_data.get("deep_sleep", 0)
        rem_sleep = self.report_data.get("rem_sleep", 0)

        if deep_sleep < 15:
            suggestions.append(
                f"Your deep sleep ratio ({deep_sleep:.1f}%) is low. This is important for physical recovery. Improve sleep conditions and daily routines.")

        if rem_sleep < 20:
            suggestions.append(
                f"Your REM sleep ratio ({rem_sleep:.1f}%) is below optimal. This affects memory consolidation. Practice relaxation techniques before bed.")

        # 其他睡眠指标建议
        if self.report_data.get("sleep_latency", 0) > 30:
            suggestions.append(
                "Your sleep latency is longer than ideal. Consider establishing a consistent pre-sleep routine.")

        # 健康指标建议
        for key, info in self.health_ranges.items():
            if key in self.health_metrics:
                value = self.health_metrics[key]
                min_val, max_val, unit = info

                # 检查是否超出正常范围
                if not (min_val <= value <= max_val):
                    status = "high" if value > max_val else "low"

                    # 格式化值
                    if unit in ["%", "bpm", "°C", "mmHg"]:
                        formatted_value = f"{value:.1f}{unit}"
                    else:
                        formatted_value = str(value)

                    # 获取英文指标名称
                    metric_name = {
                        "heart_rate": "Heart rate",
                        "blood_oxygen": "Blood oxygen",
                        "temperature": "Body temperature",
                        "respiration_rate": "Respiration rate",
                        "ambient_temp": "Ambient temperature",
                        "fatigue": "Fatigue index",
                        "systolic_bp": "Systolic blood pressure",
                        "diastolic_bp": "Diastolic blood pressure",
                        "hrv_sdnn": "Heart rate variability (SDNN)",
                        "hrv_rmssd": "Heart rate variability (RMSSD)"
                    }.get(key, key.replace("_", " ").title())

                    # 为每个异常指标生成特定建议
                    if key == "heart_rate":
                        if value > max_val:
                            suggestions.append(
                                f"Your heart rate is elevated ({formatted_value}). Reduce caffeine intake and practice relaxation techniques.")
                        else:
                            suggestions.append(
                                f"Your heart rate is unusually low ({formatted_value}). Consult a healthcare professional.")

                    elif key == "blood_oxygen":
                        if value < min_val:
                            suggestions.append(
                                f"Blood oxygen level is below normal ({formatted_value}). Ensure good air circulation in your bedroom.")

                    elif key == "temperature":
                        if value > max_val:
                            suggestions.append(
                                f"Body temperature is high ({formatted_value}). Cool the bedroom environment and wear lighter sleepwear.")
                        else:
                            suggestions.append(
                                f"Body temperature is low ({formatted_value}). Ensure adequate bedding for warmth.")

                    elif key == "fatigue":
                        if value > max_val:
                            suggestions.append(
                                f"Fatigue level is high ({formatted_value}). Prioritize rest and consider adjusting your sleep schedule.")

                    elif key in ("systolic_bp", "diastolic_bp"):
                        bp_status = "high" if value > max_val else "low"
                        suggestions.append(
                            f"Blood pressure is {bp_status} ({formatted_value}). Monitor regularly and consider professional advice.")

                    else:  # 通用建议
                        suggestions.append(
                            f"{metric_name} is {status} ({formatted_value} vs. normal range {min_val}-{max_val}{unit}). Monitor and take appropriate action.")

        # 综合睡眠质量建议
        if sleep_score < 50:
            suggestions.append(
                "Your sleep quality requires significant improvement. Focus on sleep environment, consistency, and consider consulting a sleep specialist.")
        elif sleep_score < 70:
            suggestions.append(
                "Your sleep quality has room for improvement. Implement healthier sleep habits and routines.")
        elif sleep_score >= 90:
            suggestions.append("Excellent sleep quality! Maintain your healthy sleep habits.")

        # 添加一般建议
        suggestions.append("Establish a consistent sleep schedule, even on weekends.")
        suggestions.append("Create a comfortable sleep environment: dark, quiet, and cool.")

        # 添加一条总结建议
        suggestions.append("If sleep issues persist, consult with a healthcare provider.")

        return "\n".join(suggestions)

    def generate_sleep_stage_plot_image(self):
        """Generate sleep stage plot and return image path"""
        try:
            # Load EEG data
            df = pd.read_csv(self.eeg_data_path)

            # Prepare data
            stage_mapping = {'W': 0, 'N1': 1, 'N2': 2, 'N3': 3, 'REM': 4}
            df['Stage_Numeric'] = df['Stage_Label'].map(stage_mapping)

            # Calculate sleep stage distribution
            stage_counts = df['Stage_Label'].value_counts()
            total_epochs = len(df)

            # 创建共享颜色映射的图例元素
            legend_elements = [
                Patch(facecolor=self.stage_colors[0], label=self.stage_map[0]),
                Patch(facecolor=self.stage_colors[1], label=self.stage_map[1]),
                Patch(facecolor=self.stage_colors[2], label=self.stage_map[2]),
                Patch(facecolor=self.stage_colors[3], label=self.stage_map[3]),
                Patch(facecolor=self.stage_colors[4], label=self.stage_map[4])
            ]

            # 创建图形布局 - 优化为更适于一页的尺寸
            fig = plt.figure(figsize=(12, 4.5))  # 减少高度

            # 创建GridSpec布局：饼图 | 阶段图 (1:2 比例)
            gs = gridspec.GridSpec(1, 2, width_ratios=[1.2, 1.8])  # 1:2的比例

            # 左: 饼图（包含图例）
            ax1 = plt.subplot(gs[0])
            self.create_stage_pie_chart(ax1, stage_counts, total_epochs, legend_elements=legend_elements)

            # 右: 睡眠阶段图
            ax2 = plt.subplot(gs[1])
            self.create_sleep_progression_plot(ax2, df, show_legend=False)

            # 整体图表标题
            plt.suptitle("Sleep Stage Analysis", fontsize=12, fontweight='bold', y=0.98)
            plt.tight_layout(pad=2.0, rect=[0, 0, 1, 0.95])

            # 保存图片
            combined_path = tempfile.NamedTemporaryFile(suffix='.png', delete=False).name
            plt.savefig(combined_path, dpi=150, bbox_inches='tight')
            plt.close()

            return combined_path

        except Exception as e:
            print(f"Sleep stage plot generation failed: {str(e)}")
            raise

    def add_report_header(self, pdf):
        """Add report header information"""
        # Set font and add title
        pdf.set_font("Arial", "B", 16)
        pdf.cell(0, 12, "Sleep Quality Assessment Report", ln=True, align='C')  # 减少高度
        pdf.ln(3)

        # Add generation date
        pdf.set_font("Arial", size=10)
        pdf.cell(0, 6, f"Generated Date: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}", ln=True, align='C')
        pdf.ln(5)  # 减少间距

        # Set content font
        pdf.set_font("Arial", size=10)  # 使用更小的字体
        pdf.set_text_color(0, 0, 0)  # Black

    def add_sleep_metrics_table(self, pdf, start_x, table_width):
        """Add sleep metrics table with custom position"""
        # 保存当前坐标
        current_y = pdf.get_y()
        pdf.set_x(start_x)

        sleep_metrics = [
            ("Total Sleep Duration", "sleep_duration", "hours"),
            ("Deep Sleep Ratio", "deep_sleep", "%"),
            ("Light Sleep Ratio", "light_sleep", "%"),
            ("REM Sleep Ratio", "rem_sleep", "%"),
            ("Sleep Latency", "sleep_latency", "min"),
            ("Number of Awakenings", "awakenings", "times"),
            ("Sleep Efficiency", "sleep_efficiency", "%"),
            ("Sleep Quality Score", "sleep_score", "/100")
        ]

        # 计算列宽 - 根据表格宽度动态调整
        name_width = table_width * 0.5
        value_width = table_width * 0.25
        rating_width = table_width * 0.25

        # Set table styling
        pdf.set_fill_color(220, 230, 255)  # Header background
        pdf.set_text_color(0, 0, 0)
        pdf.set_font("Arial", "B", 9)  # 使用更小的字体

        # Table header
        pdf.set_x(start_x)
        pdf.cell(name_width, 6, "Metric", border=1, fill=True)  # 减小行高
        pdf.cell(value_width, 6, "Value", border=1, fill=True)
        pdf.cell(rating_width, 6, "Rating", border=1, fill=True, ln=True)

        pdf.set_font("Arial", size=9)  # 使用更小的字体
        pdf.set_fill_color(245, 245, 245)  # Row background

        for name, key, unit in sleep_metrics:
            pdf.set_x(start_x)  # 每行开始前重置x位置

            # Get and format value
            value = self.report_data.get(key, 0)
            if key == "sleep_score":
                formatted_value = f"{value:.0f}{unit}"
            elif key == "sleep_latency":
                formatted_value = f"{value:.1f}{unit}"
            elif key == "awakenings":
                formatted_value = f"{int(value)}{unit}"
            else:
                formatted_value = f"{value:.1f}{unit}"

            # Determine color and rating
            rating_text = ""
            color = (0, 0, 0)  # Black

            if key in ["sleep_efficiency", "sleep_score"]:
                if key == "sleep_efficiency":
                    if value >= 85:
                        rating_text = "Excellent"
                        color = (34, 139, 34)  # Green
                    elif value >= 70:
                        rating_text = "Good"
                        color = (65, 105, 225)  # Blue
                    else:
                        rating_text = "Poor"
                        color = (220, 20, 60)  # Red
                else:  # sleep_score
                    if value >= 85:
                        rating_text = "Excellent"
                        color = (34, 139, 34)  # Green
                    elif value >= 70:
                        rating_text = "Good"
                        color = (65, 105, 225)  # Blue
                    else:
                        rating_text = "Poor"
                        color = (220, 20, 60)  # Red

            # Print table row
            pdf.set_text_color(0, 0, 0)  # Black text
            pdf.cell(name_width, 6, name, border=1, fill=1)  # 减小行高

            pdf.set_text_color(color[0], color[1], color[2])
            pdf.cell(value_width, 6, formatted_value, border=1, fill=1)

            if rating_text:  # For rated metrics
                pdf.set_text_color(color[0], color[1], color[2])
                pdf.cell(rating_width, 6, rating_text, border=1, fill=1, ln=True)
            else:  # For other metrics
                pdf.set_text_color(128, 128, 128)  # Gray
                pdf.cell(rating_width, 6, "", border=1, fill=1, ln=True)

    def add_health_metrics_table(self, pdf, start_x, table_width):
        """Add health metrics table with custom position"""
        # 保存当前坐标
        current_y = pdf.get_y()
        pdf.set_x(start_x)

        health_items = [
            ("heart_rate", "Heart Rate", "bpm"),
            ("blood_oxygen", "Blood Oxygen", "%"),
            ("temperature", "Body Temperature", "°C"),
            ("respiration_rate", "Respiration Rate", "bpm"),
            ("ambient_temp", "Ambient Temperature", "°C"),
            ("fatigue", "Fatigue Index", ""),
            ("systolic_bp", "Systolic BP", "mmHg"),
            ("diastolic_bp", "Diastolic BP", "mmHg")
        ]

        # 计算列宽 - 根据表格宽度动态调整
        metric_width = table_width * 0.35
        value_width = table_width * 0.20
        range_width = table_width * 0.25
        status_width = table_width * 0.20

        # Set table styling
        pdf.set_fill_color(220, 230, 255)  # Header background
        pdf.set_text_color(0, 0, 0)
        pdf.set_font("Arial", "B", 9)  # 使用更小的字体

        # Table header
        pdf.set_x(start_x)
        pdf.cell(metric_width, 6, "Health Metric", border=1, fill=True)  # 减小行高
        pdf.cell(value_width, 6, "Value", border=1, fill=True)
        pdf.cell(range_width, 6, "Normal Range", border=1, fill=True)
        pdf.cell(status_width, 6, "Status", border=1, fill=True, ln=True)

        pdf.set_font("Arial", size=9)  # 使用更小的字体
        pdf.set_fill_color(245, 245, 245)  # Row background

        for key, name, unit in health_items:
            pdf.set_x(start_x)  # 每行开始前重置x位置

            # Get value and range
            value = self.health_metrics.get(key, 0) if self.health_metrics else 0
            min_val, max_val, _ = self.health_ranges.get(key, (0, 0, ""))

            # Format value
            if unit:
                formatted_value = f"{value:.1f} {unit}"
                range_text = f"{min_val:.0f}-{max_val:.0f} {unit}"
            else:
                formatted_value = f"{value:.0f}"
                range_text = f"{min_val:.0f}-{max_val:.0f}"

            # Determine status and color
            if value < min_val:
                status = "Low"
                color = (220, 20, 60)  # Red
            elif value > max_val:
                status = "High"
                color = (220, 20, 60)  # Red
            else:
                status = "Normal"
                color = (34, 139, 34)  # Green

            # Print table row
            pdf.set_text_color(0, 0, 0)  # Black metric name
            pdf.cell(metric_width, 6, name, border=1, fill=1)

            pdf.set_text_color(color[0], color[1], color[2])  # Status color for value
            pdf.cell(value_width, 6, formatted_value, border=1, fill=1)

            pdf.set_text_color(0, 0, 0)  # Black for range
            pdf.cell(range_width, 6, range_text, border=1, fill=1)

            pdf.set_text_color(color[0], color[1], color[2])  # Status color for status
            pdf.cell(status_width, 6, status, border=1, fill=1, ln=True)

    def create_stage_pie_chart(self, ax, stage_counts, total_epochs, legend_elements=None):
        """Create pie chart with optimized layout"""
        # 只保留主要睡眠阶段（Wake, N1, N2, N3, REM）
        valid_stages = ['W', 'N1', 'N2', 'N3', 'REM']
        stage_counts = {k: v for k, v in stage_counts.items() if k in valid_stages}

        # 按顺序排列阶段
        stages_order = ['W', 'N1', 'N2', 'N3', 'REM']
        sizes = [stage_counts.get(stage, 0) for stage in stages_order]

        # 获取对应颜色的数字值
        stage_nums = {
            'W': 0,
            'N1': 1,
            'N2': 2,
            'N3': 3,
            'REM': 4
        }
        colors = [self.stage_colors[stage_nums[stage]] for stage in stages_order]

        # 创建饼图（移除阴影效果）
        wedges, _ = ax.pie(
            sizes,
            colors=colors,
            startangle=90,
            shadow=False,
            # 增加饼图边缘宽度，使饼图更饱满
            wedgeprops={'edgecolor': 'gray', 'linewidth': 0.5}
        )

        # 计算百分比
        percentages = [100 * size / total_epochs for size in sizes]

        # 添加清晰的百分比和数量标签
        for i, wedge in enumerate(wedges):
            # 百分比和数量文本
            percentage = percentages[i]
            count = sizes[i]
            label = f"{percentage:.1f}%\n({count})"

            # 计算标签位置（稍微向外移动）
            angle = (wedge.theta2 - wedge.theta1) * 0.5 + wedge.theta1
            x = 0.8 * np.cos(np.deg2rad(angle))
            y = 0.8 * np.sin(np.deg2rad(angle))

            # 添加文本（使用与楔形区对比度高的颜色）
            text_color = 'black' if percentage > 5 else 'white'
            ax.text(x, y, label,
                    ha='center', va='center',
                    fontsize=9, color=text_color,
                    fontweight='bold')

        # 添加图例（放置在饼图内部右侧）
        if legend_elements:
            # 调整图例位置在饼图内部右侧，节省空间
            ax.legend(handles=legend_elements,
                      loc='center left',
                      bbox_to_anchor=(1.05, 0.5),  # 放在饼图右侧
                      frameon=False,
                      fontsize=10)

        # 标题
        ax.set_title(f"Sleep Stage Distribution\n(Total Epochs: {total_epochs})",
                     fontsize=12, fontweight='bold', pad=10)
        ax.axis('equal')

    def create_sleep_progression_plot(self, ax, df, show_legend=False):
        """Create sleep stage progression plot (scatter plot) for subplot"""
        # Set background color
        ax.set_facecolor((0.98, 0.98, 0.98))  # Very light gray background

        # Get stage numeric values
        y_target = df['Stage_Numeric'].values

        # Create time axis in hours
        x_axis = np.arange(len(y_target)) / 120  # Convert epochs to hours (120 epochs per hour)

        # Map stages to colors
        point_colors = [self.stage_colors.get(stage, (0.8, 0.8, 0.8)) for stage in y_target]

        # Create scatter plot
        ax.scatter(x_axis, y_target, c=point_colors, s=5, alpha=0.8)

        # Set axes and labels
        ax.set_yticks(list(self.stage_map.keys()), list(self.stage_map.values()))
        ax.set_xlabel('Time (Hours)', fontsize=10, color='black')
        ax.set_ylabel('Sleep Stage', fontsize=10, color='black')
        ax.set_title('Sleep Stage Progression Over Time', fontsize=12, fontweight='bold', color='black')

        # Add grid
        ax.grid(alpha=0.3, linestyle='--', color='lightgrey')

        # Add legend (位置调整到右上角，避免与标签重叠)
        legend_elements = [
            Patch(facecolor=self.stage_colors[0], edgecolor='lightgrey', label=self.stage_map[0]),
            Patch(facecolor=self.stage_colors[1], edgecolor='lightgrey', label=self.stage_map[1]),
            Patch(facecolor=self.stage_colors[2], edgecolor='lightgrey', label=self.stage_map[2]),
            Patch(facecolor=self.stage_colors[3], edgecolor='lightgrey', label=self.stage_map[3]),
            Patch(facecolor=self.stage_colors[4], edgecolor='lightgrey', label=self.stage_map[4])
        ]
        if show_legend:
            ax.legend(handles=legend_elements, loc='upper right', fontsize=9)